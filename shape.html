<html>

<head>
    <script src="https://cdn.jsdelivr.net/npm/onnxjs/dist/onnx.min.js"></script>
    <style>
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        canvas {
            border: 1px solid black;
            margin: 0.25em;
        }

        /* #mini-canvas {
            display: none;
        } */

        #predictions {
            margin-top: 1em;
            font-size: 2em;
        }
    </style>
</head>

<body>
    <h1>Shape Reco Example</h1>
    <canvas id="canvas" width="400" height="400"></canvas>
    <canvas id="mini-canvas" width="64" height="64"></canvas>
    <button onclick="ctx.clearRect(0, 0, canvas.width, canvas.height);">Clear</button>

    <div><input type="button" value="Run" onclick="runExample()" /></div>
    <div id="predictions"></div>
</body>
<script>

    const session = new onnx.InferenceSession();
    session.loadModel("./shape_reco.onnx");

    var canvas = document.getElementById('canvas');
    var ctx = canvas.getContext('2d');
    var minicanvas = document.getElementById('mini-canvas');
    var minictx = minicanvas.getContext('2d');
    // draw a square in the center of the canvas
    ctx.strokeStyle = 'dimgrey';
    ctx.lineWidth = 10;
    ctx.lineCap = "round";
    ctx.strokeRect(100, 100, 200, 200);

    // allow drawing when click on the canvas
    var isDrawing = false;
    var lastX;
    var lastY;
    canvas.addEventListener('mousedown', function (e) {
        isDrawing = true;
        lastX = e.offsetX;
        lastY = e.offsetY;
    });
    canvas.addEventListener('mousemove', function (e) {
        if (isDrawing === true) {
            ctx.beginPath();
            ctx.moveTo(lastX, lastY);
            ctx.lineTo(e.offsetX, e.offsetY);
            ctx.stroke();
            lastX = e.offsetX;
            lastY = e.offsetY;
        }
    });
    canvas.addEventListener('mouseup', function (e) {
        isDrawing = false;
    });

    async function runExample() {
        minictx.clearRect(0, 0, minicanvas.width, minicanvas.height);
        minictx.drawImage(canvas, 0, 0, minicanvas.width, minicanvas.height);
        img = minictx.getImageData(0, 0, minicanvas.width, minicanvas.height);
        x = new Float32Array(minicanvas.width * minicanvas.height * 3);
        for (let i = 0; i < minicanvas.height; i++) {
            for (let j = 0; j < minicanvas.width; j++) {
                x[0 * minicanvas.width * minicanvas.height + i * minicanvas.width + j] = img.data[4 * (i * minicanvas.width + j) + 0] / 255;
                x[1 * minicanvas.width * minicanvas.height + i * minicanvas.width + j] = img.data[4 * (i * minicanvas.width + j) + 1] / 255;
                x[2 * minicanvas.width * minicanvas.height + i * minicanvas.width + j] = img.data[4 * (i * minicanvas.width + j) + 2] / 255;
            }
        }
        const tensorX = new onnx.Tensor(x, 'float32', [1, 3, minicanvas.width, minicanvas.height]);
        const outputMap = await session.run([tensorX]);
        const outputValue = outputMap.values().next().value.data;
        document.getElementById('predictions').innerHTML = outputValue;
    }

</script>

</html>